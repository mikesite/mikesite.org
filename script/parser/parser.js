"use strict";
define(function (require, exports, module) {
    module.exports = /*
     * Generated by PEG.js 0.10.0.
     *
     * http://pegjs.org/
     */
        (function () {
            "use strict";
            function peg$subclass(child, parent) {
                function ctor() { this.constructor = child; }
                ctor.prototype = parent.prototype;
                child.prototype = new ctor();
            }
            function peg$SyntaxError(message, expected, found, location) {
                this.message = message;
                this.expected = expected;
                this.found = found;
                this.location = location;
                this.name = "SyntaxError";
                if (typeof Error.captureStackTrace === "function") {
                    Error.captureStackTrace(this, peg$SyntaxError);
                }
            }
            peg$subclass(peg$SyntaxError, Error);
            peg$SyntaxError.buildMessage = function (expected, found) {
                var DESCRIBE_EXPECTATION_FNS = {
                    literal: function (expectation) {
                        return "\"" + literalEscape(expectation.text) + "\"";
                    },
                    "class": function (expectation) {
                        var escapedParts = "", i;
                        for (i = 0; i < expectation.parts.length; i++) {
                            escapedParts += expectation.parts[i] instanceof Array
                                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                                : classEscape(expectation.parts[i]);
                        }
                        return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
                    },
                    any: function (expectation) {
                        return "any character";
                    },
                    end: function (expectation) {
                        return "end of input";
                    },
                    other: function (expectation) {
                        return expectation.description;
                    }
                };
                function hex(ch) {
                    return ch.charCodeAt(0).toString(16).toUpperCase();
                }
                function literalEscape(s) {
                    return s
                        .replace(/\\/g, '\\\\')
                        .replace(/"/g, '\\"')
                        .replace(/\0/g, '\\0')
                        .replace(/\t/g, '\\t')
                        .replace(/\n/g, '\\n')
                        .replace(/\r/g, '\\r')
                        .replace(/[\x00-\x0F]/g, function (ch) { return '\\x0' + hex(ch); })
                        .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return '\\x' + hex(ch); });
                }
                function classEscape(s) {
                    return s
                        .replace(/\\/g, '\\\\')
                        .replace(/\]/g, '\\]')
                        .replace(/\^/g, '\\^')
                        .replace(/-/g, '\\-')
                        .replace(/\0/g, '\\0')
                        .replace(/\t/g, '\\t')
                        .replace(/\n/g, '\\n')
                        .replace(/\r/g, '\\r')
                        .replace(/[\x00-\x0F]/g, function (ch) { return '\\x0' + hex(ch); })
                        .replace(/[\x10-\x1F\x7F-\x9F]/g, function (ch) { return '\\x' + hex(ch); });
                }
                function describeExpectation(expectation) {
                    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
                }
                function describeExpected(expected) {
                    var descriptions = new Array(expected.length), i, j;
                    for (i = 0; i < expected.length; i++) {
                        descriptions[i] = describeExpectation(expected[i]);
                    }
                    descriptions.sort();
                    if (descriptions.length > 0) {
                        for (i = 1, j = 1; i < descriptions.length; i++) {
                            if (descriptions[i - 1] !== descriptions[i]) {
                                descriptions[j] = descriptions[i];
                                j++;
                            }
                        }
                        descriptions.length = j;
                    }
                    switch (descriptions.length) {
                        case 1:
                            return descriptions[0];
                        case 2:
                            return descriptions[0] + " or " + descriptions[1];
                        default:
                            return descriptions.slice(0, -1).join(", ")
                                + ", or "
                                + descriptions[descriptions.length - 1];
                    }
                }
                function describeFound(found) {
                    return found ? "\"" + literalEscape(found) + "\"" : "end of input";
                }
                return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
            };
            function peg$parse(input, options) {
                options = options !== void 0 ? options : {};
                var peg$FAILED = {}, peg$startRuleIndices = { Filter: 0 }, peg$startRuleIndex = 0, peg$consts = [
                    function (f) { return 'return ' + f + ';'; },
                    function () { return 'return true;'; },
                    "|",
                    peg$literalExpectation("|", false),
                    "or",
                    peg$literalExpectation("OR", true),
                    function (h, t) { return t.reduce(function (t, e) { return t + '||' + e[3]; }, h); },
                    "&",
                    peg$literalExpectation("&", false),
                    "and",
                    peg$literalExpectation("AND", true),
                    function (h, t) { return t.reduce(function (t, e) { return t + '&&' + e[3]; }, h); },
                    "^",
                    peg$literalExpectation("^", false),
                    "xor",
                    peg$literalExpectation("XOR", true),
                    function (l, r) { return l + '!=' + r; },
                    "!",
                    peg$literalExpectation("!", false),
                    "not",
                    peg$literalExpectation("NOT", true),
                    function (f) { return '!' + f; },
                    "(",
                    peg$literalExpectation("(", false),
                    ")",
                    peg$literalExpectation(")", false),
                    function (f) { return '(' + f + ')'; },
                    "[",
                    peg$literalExpectation("[", false),
                    "]",
                    peg$literalExpectation("]", false),
                    /^[=!]/,
                    peg$classExpectation(["=", "!"], false, false),
                    /^[=~]/,
                    peg$classExpectation(["=", "~"], false, false),
                    function (f, n, e, v) { return 't(o,' + f + ',' + v + ',' + (n == '=') + ',' + (e == '=') + ')'; },
                    function (b) { return 'i[' + b + ']'; },
                    "{",
                    peg$literalExpectation("{", false),
                    "}",
                    peg$literalExpectation("}", false),
                    function (f, c, v) { return 'n(o,' + f + ',' + v + ',' + c + ')'; },
                    /^[!=]/,
                    peg$classExpectation(["!", "="], false, false),
                    "=",
                    peg$literalExpectation("=", false),
                    function (n) { return '[true,' + (n == '=') + ']'; },
                    /^[<>]/,
                    peg$classExpectation(["<", ">"], false, false),
                    function (c, e) { return '[false,' + (!!e) + ',' + (c == '<') + ']'; },
                    function (b) { return 'parseInt(i[' + b + '])'; },
                    "<",
                    peg$literalExpectation("<", false),
                    ">",
                    peg$literalExpectation(">", false),
                    function (q, p) { return 'r(o,e,i,"+switch",' + q + ',function(o,e,i){return ' + p + ';})'; },
                    function () { return 'true'; },
                    function () { return '[0]'; },
                    "?",
                    peg$literalExpectation("?", false),
                    function () { return '[1]'; },
                    "~",
                    peg$literalExpectation("~", false),
                    function (l, u) { return '[2,' + l + ',' + u + ']'; },
                    /^[+\-]/,
                    peg$classExpectation(["+", "-"], false, false),
                    function (p, t) { return '[3,' + p + ',' + (t ? (t == '+' ? 1 : -1) : 0) + ']'; },
                    function (q, p) { return 'r(o,e,i,"allC",' + q + ',function(o,e,i){return ' + p + ';})'; },
                    "~>",
                    peg$literalExpectation("~>", false),
                    function (b, p) { return 'b(o,e,i,' + b + ',function(o,e,i){return ' + p + ';})'; },
                    "@@(",
                    peg$literalExpectation("@@(", false),
                    function (b) { return '[' + b.map(function (e) { return e[0]; }).join(',') + ']'; },
                    function (b) { return '[' + b + ']'; },
                    "@",
                    peg$literalExpectation("@", false),
                    function (f, b) { return '[' + b + ',' + f + ']'; },
                    peg$otherExpectation("bind/bound id"),
                    "#",
                    peg$literalExpectation("#", false),
                    function (b) { return b; },
                    peg$otherExpectation("natural number"),
                    /^[0-9]/,
                    peg$classExpectation([["0", "9"]], false, false),
                    function () { return parseInt(text(), 10); },
                    peg$otherExpectation("signed natural number"),
                    "-",
                    peg$literalExpectation("-", false),
                    function (n, v) { return '[' + v + ',' + !n + ']'; },
                    peg$otherExpectation("integer"),
                    peg$otherExpectation("field name"),
                    /^[a-zA-Z0-9_ ]/,
                    peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"], "_", " "], false, false),
                    function () { return '"' + text() + '"'; },
                    peg$otherExpectation("string"),
                    "\"",
                    peg$literalExpectation("\"", false),
                    /^[^\\"]/,
                    peg$classExpectation(["\\", "\""], true, false),
                    function () { return text(); },
                    peg$otherExpectation("spaces"),
                    /^[ \t\n\r]/,
                    peg$classExpectation([" ", "\t", "\n", "\r"], false, false)
                ], peg$bytecode = [
                    peg$decode("%;9/:#;!/1$;9/($8#: #!!)(#'#(\"'#&'#.. &%;9/& 8!:!! )"),
                    peg$decode("%;\"/\xE3#$%;9/n#%2\"\"\"6\"7#/7#2\"\"\"6\"7#.\" &\"/#$+\")(\"'#&'#.) &3$\"\"5\"7%/5$;9/,$;\"/#$+$)($'#(#'#(\"'#&'#0x*%;9/n#%2\"\"\"6\"7#/7#2\"\"\"6\"7#.\" &\"/#$+\")(\"'#&'#.) &3$\"\"5\"7%/5$;9/,$;\"/#$+$)($'#(#'#(\"'#&'#&/)$8\":&\"\"! )(\"'#&'#"),
                    peg$decode("%;#/\xE3#$%;9/n#%2'\"\"6'7(/7#2'\"\"6'7(.\" &\"/#$+\")(\"'#&'#.) &3)\"\"5#7*/5$;9/,$;#/#$+$)($'#(#'#(\"'#&'#0x*%;9/n#%2'\"\"6'7(/7#2'\"\"6'7(.\" &\"/#$+\")(\"'#&'#.) &3)\"\"5#7*/5$;9/,$;#/#$+$)($'#(#'#(\"'#&'#&/)$8\":+\"\"! )(\"'#&'#"),
                    peg$decode("%;$/_#;9/V$2,\"\"6,7-.) &3.\"\"5#7//;$;9/2$;$/)$8%:0%\"$ )(%'#($'#(#'#(\"'#&'#.# &;$"),
                    peg$decode("%21\"\"6172.) &33\"\"5#74/:#;9/1$;$/($8#:5#! )(#'#(\"'#&'#.# &;%"),
                    peg$decode("%26\"\"6677/R#;9/I$;!/@$;9/7$28\"\"6879/($8%::%!\")(%'#($'#(#'#(\"'#&'#.# &;&"),
                    peg$decode(";'.5 &;)./ &;,.) &;/.# &;0"),
                    peg$decode("%2;\"\"6;7</\x81#;7.\" &\"/s$2=\"\"6=7>/d$;9/[$4?\"\"5!7@/L$4A\"\"5!7B/=$;9/4$;(/+$8(:C($&#\" )(('#(''#(&'#(%'#($'#(#'#(\"'#&'#"),
                    peg$decode(";8./ &%;3/' 8!:D!! )"),
                    peg$decode("%2E\"\"6E7F/f#;7/]$2G\"\"6G7H/N$;9/E$;*/<$;9/3$;+/*$8':I'#%\" )(''#(&'#(%'#($'#(#'#(\"'#&'#"),
                    peg$decode("%4J\"\"5!7K/7#2L\"\"6L7M/($8\":N\"!!)(\"'#&'#.M &%4O\"\"5!7P/=#2L\"\"6L7M.\" &\"/)$8\":Q\"\"! )(\"'#&'#"),
                    peg$decode(";6./ &%;3/' 8!:R!! )"),
                    peg$decode("%2S\"\"6S7T/e#;9/\\$;./S$;9/J$2U\"\"6U7V/;$;9/2$;-/)$8':W'\"$ )(''#(&'#(%'#($'#(#'#(\"'#&'#"),
                    peg$decode(";%.O &%26\"\"6677/?#;9/6$28\"\"6879/'$8#:X# )(#'#(\"'#&'#"),
                    peg$decode("%21\"\"6172/& 8!:Y! ).\xA7 &%2Z\"\"6Z7[/& 8!:\\! ).\x90 &%;5/S#;9/J$2]\"\"6]7^/;$;9/2$;5/)$8%:_%\"$ )(%'#($'#(#'#(\"'#&'#.P &%;5/F#;9/=$4`\"\"5!7a.\" &\"/)$8#:b#\"\" )(#'#(\"'#&'#"),
                    peg$decode("%2U\"\"6U7V/e#;9/\\$;./S$;9/J$2S\"\"6S7T/;$;9/2$;%/)$8':c'\"$ )(''#(&'#(%'#($'#(#'#(\"'#&'#"),
                    peg$decode("%;1/S#;9/J$2d\"\"6d7e/;$;9/2$;%/)$8%:f%\"$ )(%'#($'#(#'#(\"'#&'#"),
                    peg$decode("%2g\"\"6g7h/|#;9/s$$%;2/,#;9/#$+\")(\"'#&'#/9#06*%;2/,#;9/#$+\")(\"'#&'#&&&#/7$28\"\"6879/($8$:i$!!)($'#(#'#(\"'#&'#./ &%;2/' 8!:j!! )"),
                    peg$decode("%2k\"\"6k7l/;#;7/2$;3/)$8#:m#\"! )(#'#(\"'#&'#"),
                    peg$decode("<%2o\"\"6o7p/1#;4/($8\":q\"! )(\"'#&'#=.\" 7n"),
                    peg$decode("<%$4s\"\"5!7t/,#0)*4s\"\"5!7t&&&#/& 8!:u! )=.\" 7r"),
                    peg$decode("<%2w\"\"6w7x.\" &\"/2#;4/)$8\":y\"\"! )(\"'#&'#=.\" 7v"),
                    peg$decode("<%2w\"\"6w7x.\" &\"/0#;4/'$8\":u\" )(\"'#&'#=.\" 7z"),
                    peg$decode("<%$4|\"\"5!7}/,#0)*4|\"\"5!7}&&&#/& 8!:~! )=.\" 7{"),
                    peg$decode("<%2\x80\"\"6\x807\x81/R#$4\x82\"\"5!7\x830)*4\x82\"\"5!7\x83&/6$2\x80\"\"6\x807\x81/'$8#:\x84# )(#'#(\"'#&'#=.\" 7\x7F"),
                    peg$decode("<$4\x86\"\"5!7\x870)*4\x86\"\"5!7\x87&=.\" 7\x85")
                ], peg$currPos = 0, peg$savedPos = 0, peg$posDetailsCache = [{ line: 1, column: 1 }], peg$maxFailPos = 0, peg$maxFailExpected = [], peg$silentFails = 0, peg$result;
                if ("startRule" in options) {
                    if (!(options.startRule in peg$startRuleIndices)) {
                        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
                    }
                    peg$startRuleIndex = peg$startRuleIndices[options.startRule];
                }
                function text() {
                    return input.substring(peg$savedPos, peg$currPos);
                }
                function location() {
                    return peg$computeLocation(peg$savedPos, peg$currPos);
                }
                function expected(description, location) {
                    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
                    throw peg$buildStructuredError([peg$otherExpectation(description)], input.substring(peg$savedPos, peg$currPos), location);
                }
                function error(message, location) {
                    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos);
                    throw peg$buildSimpleError(message, location);
                }
                function peg$literalExpectation(text, ignoreCase) {
                    return { type: "literal", text: text, ignoreCase: ignoreCase };
                }
                function peg$classExpectation(parts, inverted, ignoreCase) {
                    return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
                }
                function peg$anyExpectation() {
                    return { type: "any" };
                }
                function peg$endExpectation() {
                    return { type: "end" };
                }
                function peg$otherExpectation(description) {
                    return { type: "other", description: description };
                }
                function peg$computePosDetails(pos) {
                    var details = peg$posDetailsCache[pos], p;
                    if (details) {
                        return details;
                    }
                    else {
                        p = pos - 1;
                        while (!peg$posDetailsCache[p]) {
                            p--;
                        }
                        details = peg$posDetailsCache[p];
                        details = {
                            line: details.line,
                            column: details.column
                        };
                        while (p < pos) {
                            if (input.charCodeAt(p) === 10) {
                                details.line++;
                                details.column = 1;
                            }
                            else {
                                details.column++;
                            }
                            p++;
                        }
                        peg$posDetailsCache[pos] = details;
                        return details;
                    }
                }
                function peg$computeLocation(startPos, endPos) {
                    var startPosDetails = peg$computePosDetails(startPos), endPosDetails = peg$computePosDetails(endPos);
                    return {
                        start: {
                            offset: startPos,
                            line: startPosDetails.line,
                            column: startPosDetails.column
                        },
                        end: {
                            offset: endPos,
                            line: endPosDetails.line,
                            column: endPosDetails.column
                        }
                    };
                }
                function peg$fail(expected) {
                    if (peg$currPos < peg$maxFailPos) {
                        return;
                    }
                    if (peg$currPos > peg$maxFailPos) {
                        peg$maxFailPos = peg$currPos;
                        peg$maxFailExpected = [];
                    }
                    peg$maxFailExpected.push(expected);
                }
                function peg$buildSimpleError(message, location) {
                    return new peg$SyntaxError(message, null, null, location);
                }
                function peg$buildStructuredError(expected, found, location) {
                    return new peg$SyntaxError(peg$SyntaxError.buildMessage(expected, found), expected, found, location);
                }
                function peg$decode(s) {
                    var bc = new Array(s.length), i;
                    for (i = 0; i < s.length; i++) {
                        bc[i] = s.charCodeAt(i) - 32;
                    }
                    return bc;
                }
                function peg$parseRule(index) {
                    var bc = peg$bytecode[index], ip = 0, ips = [], end = bc.length, ends = [], stack = [], params, i;
                    while (true) {
                        while (ip < end) {
                            switch (bc[ip]) {
                                case 0:
                                    stack.push(peg$consts[bc[ip + 1]]);
                                    ip += 2;
                                    break;
                                case 1:
                                    stack.push(void 0);
                                    ip++;
                                    break;
                                case 2:
                                    stack.push(null);
                                    ip++;
                                    break;
                                case 3:
                                    stack.push(peg$FAILED);
                                    ip++;
                                    break;
                                case 4:
                                    stack.push([]);
                                    ip++;
                                    break;
                                case 5:
                                    stack.push(peg$currPos);
                                    ip++;
                                    break;
                                case 6:
                                    stack.pop();
                                    ip++;
                                    break;
                                case 7:
                                    peg$currPos = stack.pop();
                                    ip++;
                                    break;
                                case 8:
                                    stack.length -= bc[ip + 1];
                                    ip += 2;
                                    break;
                                case 9:
                                    stack.splice(-2, 1);
                                    ip++;
                                    break;
                                case 10:
                                    stack[stack.length - 2].push(stack.pop());
                                    ip++;
                                    break;
                                case 11:
                                    stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));
                                    ip += 2;
                                    break;
                                case 12:
                                    stack.push(input.substring(stack.pop(), peg$currPos));
                                    ip++;
                                    break;
                                case 13:
                                    ends.push(end);
                                    ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                                    if (stack[stack.length - 1]) {
                                        end = ip + 3 + bc[ip + 1];
                                        ip += 3;
                                    }
                                    else {
                                        end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                        ip += 3 + bc[ip + 1];
                                    }
                                    break;
                                case 14:
                                    ends.push(end);
                                    ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                                    if (stack[stack.length - 1] === peg$FAILED) {
                                        end = ip + 3 + bc[ip + 1];
                                        ip += 3;
                                    }
                                    else {
                                        end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                        ip += 3 + bc[ip + 1];
                                    }
                                    break;
                                case 15:
                                    ends.push(end);
                                    ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                                    if (stack[stack.length - 1] !== peg$FAILED) {
                                        end = ip + 3 + bc[ip + 1];
                                        ip += 3;
                                    }
                                    else {
                                        end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                        ip += 3 + bc[ip + 1];
                                    }
                                    break;
                                case 16:
                                    if (stack[stack.length - 1] !== peg$FAILED) {
                                        ends.push(end);
                                        ips.push(ip);
                                        end = ip + 2 + bc[ip + 1];
                                        ip += 2;
                                    }
                                    else {
                                        ip += 2 + bc[ip + 1];
                                    }
                                    break;
                                case 17:
                                    ends.push(end);
                                    ips.push(ip + 3 + bc[ip + 1] + bc[ip + 2]);
                                    if (input.length > peg$currPos) {
                                        end = ip + 3 + bc[ip + 1];
                                        ip += 3;
                                    }
                                    else {
                                        end = ip + 3 + bc[ip + 1] + bc[ip + 2];
                                        ip += 3 + bc[ip + 1];
                                    }
                                    break;
                                case 18:
                                    ends.push(end);
                                    ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                                    if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]) {
                                        end = ip + 4 + bc[ip + 2];
                                        ip += 4;
                                    }
                                    else {
                                        end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                                        ip += 4 + bc[ip + 2];
                                    }
                                    break;
                                case 19:
                                    ends.push(end);
                                    ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                                    if (input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]) {
                                        end = ip + 4 + bc[ip + 2];
                                        ip += 4;
                                    }
                                    else {
                                        end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                                        ip += 4 + bc[ip + 2];
                                    }
                                    break;
                                case 20:
                                    ends.push(end);
                                    ips.push(ip + 4 + bc[ip + 2] + bc[ip + 3]);
                                    if (peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))) {
                                        end = ip + 4 + bc[ip + 2];
                                        ip += 4;
                                    }
                                    else {
                                        end = ip + 4 + bc[ip + 2] + bc[ip + 3];
                                        ip += 4 + bc[ip + 2];
                                    }
                                    break;
                                case 21:
                                    stack.push(input.substr(peg$currPos, bc[ip + 1]));
                                    peg$currPos += bc[ip + 1];
                                    ip += 2;
                                    break;
                                case 22:
                                    stack.push(peg$consts[bc[ip + 1]]);
                                    peg$currPos += peg$consts[bc[ip + 1]].length;
                                    ip += 2;
                                    break;
                                case 23:
                                    stack.push(peg$FAILED);
                                    if (peg$silentFails === 0) {
                                        peg$fail(peg$consts[bc[ip + 1]]);
                                    }
                                    ip += 2;
                                    break;
                                case 24:
                                    peg$savedPos = stack[stack.length - 1 - bc[ip + 1]];
                                    ip += 2;
                                    break;
                                case 25:
                                    peg$savedPos = peg$currPos;
                                    ip++;
                                    break;
                                case 26:
                                    params = bc.slice(ip + 4, ip + 4 + bc[ip + 3]);
                                    for (i = 0; i < bc[ip + 3]; i++) {
                                        params[i] = stack[stack.length - 1 - params[i]];
                                    }
                                    stack.splice(stack.length - bc[ip + 2], bc[ip + 2], peg$consts[bc[ip + 1]].apply(null, params));
                                    ip += 4 + bc[ip + 3];
                                    break;
                                case 27:
                                    stack.push(peg$parseRule(bc[ip + 1]));
                                    ip += 2;
                                    break;
                                case 28:
                                    peg$silentFails++;
                                    ip++;
                                    break;
                                case 29:
                                    peg$silentFails--;
                                    ip++;
                                    break;
                                default:
                                    throw new Error("Invalid opcode: " + bc[ip] + ".");
                            }
                        }
                        if (ends.length > 0) {
                            end = ends.pop();
                            ip = ips.pop();
                        }
                        else {
                            break;
                        }
                    }
                    return stack[0];
                }
                peg$result = peg$parseRule(peg$startRuleIndex);
                if (peg$result !== peg$FAILED && peg$currPos === input.length) {
                    return peg$result;
                }
                else {
                    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
                        peg$fail(peg$endExpectation());
                    }
                    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length
                        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
                        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
                }
            }
            return {
                SyntaxError: peg$SyntaxError,
                parse: peg$parse
            };
        })();
});
